<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AES-256-GCM + æ—¥æ–‡Base åŠ è§£å¯†å·¥å…·ï¼ˆæ”¯æŒå¤§æ–‡ä»¶ï¼‰</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            background-attachment: fixed;
            min-height: 100vh;
        }
        .glass {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .loading {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #e5e7eb;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
        }
        .progress-fill {
            height: 100%;
            background: #3b82f6;
            width: 0%;
            transition: width 0.3s ease;
        }
        #dragOverlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(59, 130, 246, 0.3);
            backdrop-filter: blur(4px);
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: white;
            font-weight: bold;
            z-index: 1000;
            pointer-events: none;
        }
        .process-progress {
            display: none;
            margin-top: 1rem;
        }
        .process-progress.active {
            display: block;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .processing {
            animation: pulse 1.5s ease-in-out infinite;
        }
    </style>
</head>
<body class="flex items-center justify-center p-4">
    <div id="dragOverlay">æ‹–å…¥æ–‡ä»¶åˆ°æ­¤å¤„å¯¼å…¥</div>
    
    <div class="glass rounded-xl shadow-2xl p-6 max-w-2xl w-full relative">
        <div id="loadingSpinner" class="loading">
            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
        </div>
        
        <h1 class="text-2xl font-bold text-center text-gray-800 mb-2">ğŸ” AES-256-GCM åŠ è§£å¯†å·¥å…·</h1>
        <p class="text-center text-gray-600 text-sm mb-6">æ”¯æŒä»»æ„å¤§å°æ–‡ä»¶ Â· çº¯å‰ç«¯å¤„ç† Â· æ•°æ®ä¸ä¸Šä¼ </p>
        
        <div class="mb-6 text-center">
            <span id="modeIndicator" class="inline-flex items-center px-4 py-2 rounded-full text-sm font-medium bg-blue-100 text-blue-800">
                <span class="w-2 h-2 bg-blue-600 rounded-full mr-2"></span>
                <span id="modeText">å½“å‰æ¨¡å¼ï¼šåŠ å¯†</span>
            </span>
        </div>
        
        <div class="mb-6 bg-gray-50 rounded-lg p-4 border">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-medium text-gray-700">å¯†é’¥è®¾ç½®</h3>
                <button type="button" id="toggleAdvanced" class="text-sm text-blue-600 hover:text-blue-800">
                    æ˜¾ç¤ºé«˜çº§é€‰é¡¹
                </button>
            </div>
            <div class="mb-4">
                <label class="inline-flex items-center">
                    <input id="useCustomKey" type="checkbox" class="form-checkbox h-5 w-5 text-blue-600">
                    <span class="ml-2 text-sm font-medium text-gray-600">å¯ç”¨è‡ªå®šä¹‰å¯†é’¥</span>
                </label>
                <p class="text-xs text-gray-500 ml-7 mt-1">ä¸å¯ç”¨åˆ™ä½¿ç”¨é»˜è®¤å¯†é’¥</p>
            </div>
            <div id="keyInputContainer" class="mb-4 hidden">
                <label class="block text-sm font-medium text-gray-600 mb-1">è¾“å…¥å¯†é’¥/å¯†ç </label>
                <div class="relative">
                    <input id="keyInput" type="password" class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                           placeholder="å»ºè®®12ä½ä»¥ä¸Šï¼Œå«å¤§å°å†™+æ•°å­—+ç¬¦å·">
                    <button type="button" id="toggleKeyVisibility" class="absolute right-3 top-3 text-gray-500 hover:text-gray-700">
                        ğŸ‘ï¸
                    </button>
                </div>
                <div class="flex items-center mt-2">
                    <div class="progress-bar flex-1">
                        <div id="keyStrengthBar" class="progress-fill"></div>
                    </div>
                    <span id="keyStrengthText" class="ml-2 text-xs text-gray-500">å¯†é’¥å¼ºåº¦</span>
                </div>
            </div>
            <div id="advancedOptions" class="hidden space-y-4 mt-4 pt-4 border-t">
                <div>
                    <label class="block text-sm font-medium text-gray-600 mb-1">ç›å€¼ï¼ˆSaltï¼Œå¯é€‰åå…­è¿›åˆ¶ï¼‰</label>
                    <input id="saltInput" type="text" class="w-full p-2 border rounded-md"
                           placeholder="ç•™ç©ºè‡ªåŠ¨ç”Ÿæˆéšæœºç›å€¼">
                    <p class="text-xs text-gray-500 mt-1">è‡ªå®šä¹‰ç›å€¼éœ€åœ¨è§£å¯†æ—¶æ‰‹åŠ¨è¾“å…¥ç›¸åŒå€¼</p>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-600 mb-1">è¿­ä»£æ¬¡æ•°</label>
                    <input id="iterationsInput" type="number" value="200000" min="1000" max="1000000"
                           class="w-full p-2 border rounded-md">
                    <p class="text-xs text-gray-500 mt-1">é»˜è®¤200000ï¼Œæ›´é«˜æ›´å®‰å…¨ä½†é€Ÿåº¦ç¨æ…¢ï¼ˆä¸Šé™1000000ï¼‰</p>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-600 mb-1">è¾“å‡ºæ ¼å¼</label>
                    <select id="outputFormat" class="w-full p-2 border rounded-md">
                        <option value="base">æ—¥æ–‡Baseæ–‡æœ¬ï¼ˆé€‚åˆå°æ–‡ä»¶ï¼‰</option>
                        <option value="binary">äºŒè¿›åˆ¶.encæ–‡ä»¶ï¼ˆæ¨èå¤§æ–‡ä»¶ï¼‰</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-600 mb-1">åˆ†å—å¤§å°ï¼ˆMBï¼‰</label>
                    <input id="chunkSize" type="number" value="10" min="1" max="100"
                           class="w-full p-2 border rounded-md">
                    <p class="text-xs text-gray-500 mt-1">è¾ƒå°çš„åˆ†å—å¯å‡å°‘å†…å­˜å ç”¨ï¼Œå»ºè®®5-20MB</p>
                </div>
            </div>
        </div>
        
        <div class="mb-6">
            <div class="flex justify-between items-center mb-2">
                <label id="inputLabel" class="block text-sm font-medium text-gray-600">è¾“å…¥æ˜æ–‡æˆ–ä»»æ„æ–‡ä»¶</label>
                <span id="charCount" class="text-sm text-gray-500">0 å­—ç¬¦</span>
            </div>
            <textarea id="inputText" rows="5"
                      class="w-full p-4 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-base"
                      placeholder="åŠ å¯†è¯·è¾“å…¥æ˜æ–‡æˆ–å¯¼å…¥ä»»æ„æ–‡ä»¶ï¼ˆæ”¯æŒç™¾GBçº§åˆ«ï¼‰ï¼Œè§£å¯†è¯·è¾“å…¥æ—¥æ–‡å¯†æ–‡æˆ–å¯¼å…¥.encæ–‡ä»¶"></textarea>
            <div class="mt-2">
                <label class="bg-blue-500 text-white px-4 py-2 rounded cursor-pointer hover:bg-blue-600 inline-block">
                    ğŸ“ é€‰æ‹©æ–‡ä»¶ï¼ˆæ”¯æŒä»»æ„å¤§å°ï¼‰ <input type="file" id="importFile" class="hidden" accept="*/*">
                </label>
            </div>
            <p id="inputInfo" class="text-sm text-gray-500 mt-1"></p>
        </div>
        
        <div class="process-progress" id="processProgress">
            <div class="bg-gray-100 rounded-lg p-4 border">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-sm font-medium text-gray-700">å¤„ç†è¿›åº¦</span>
                    <span id="progressPercent" class="text-sm font-medium text-blue-600">0%</span>
                </div>
                <div class="progress-bar h-6">
                    <div id="progressFill" class="progress-fill bg-gradient-to-r from-blue-500 to-purple-500"></div>
                </div>
                <div class="mt-2 text-xs text-gray-600 space-y-1">
                    <div class="flex justify-between">
                        <span>å·²å¤„ç†ï¼š</span>
                        <span id="processedSize" class="font-medium">0 MB</span>
                    </div>
                    <div class="flex justify-between">
                        <span>æ€»å¤§å°ï¼š</span>
                        <span id="totalSize" class="font-medium">0 MB</span>
                    </div>
                    <div class="flex justify-between">
                        <span>é¢„è®¡å‰©ä½™æ—¶é—´ï¼š</span>
                        <span id="remainingTime" class="font-medium">è®¡ç®—ä¸­...</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="flex flex-wrap justify-center gap-3 mb-6">
            <button id="encryptButton" class="flex-1 min-w-[120px] bg-blue-600 text-white py-3 px-4 rounded-lg hover:bg-blue-700 font-medium flex items-center justify-center">
                <span>ğŸ”’</span><span class="ml-2">åŠ å¯†</span>
            </button>
            <button id="decryptButton" class="flex-1 min-w-[120px] bg-green-600 text-white py-3 px-4 rounded-lg hover:bg-green-700 font-medium flex items-center justify-center">
                <span>ğŸ”“</span><span class="ml-2">è§£å¯†</span>
            </button>
            <button id="clearButton" class="flex-1 min-w-[120px] bg-gray-500 text-white py-3 px-4 rounded-lg hover:bg-gray-600 font-medium flex items-center justify-center">
                <span>ğŸ—‘ï¸</span><span class="ml-2">æ¸…ç©º</span>
            </button>
        </div>
        
        <div class="mb-6">
            <div class="flex justify-between items-center mb-2">
                <label id="outputLabel" class="block text-sm font-medium text-gray-600">ç»“æœ</label>
                <button id="copyAllButton" class="text-sm text-blue-600 hover:text-blue-800 hidden">å¤åˆ¶å…¨éƒ¨</button>
            </div>
            <div id="outputContainer" class="w-full border rounded-lg bg-gray-50 overflow-hidden">
                <textarea id="outputText" rows="5" class="w-full p-4 font-mono text-base hidden" readonly></textarea>
                <img id="outputImage" class="max-w-full h-auto hidden" alt="è§£å¯†å›¾ç‰‡é¢„è§ˆ">
            </div>
            <div id="outputInfo" class="mt-3 space-y-2">
                <div class="flex justify-between text-sm"><span class="text-gray-600">æ“ä½œçŠ¶æ€ï¼š</span><span id="operationStatus" class="text-gray-800">å°±ç»ª</span></div>
                <div class="flex justify-between text-sm"><span class="text-gray-600">æ•°æ®å¤§å°ï¼š</span><span id="dataSize" class="text-gray-800">-</span></div>
                <div class="flex justify-between text-sm"><span class="text-gray-600">å¤„ç†æ—¶é—´ï¼š</span><span id="processingTime" class="text-gray-800">-</span></div>
            </div>
        </div>
        
        <div class="flex flex-wrap justify-center gap-3">
            <button id="copyButton" class="flex-1 min-w-[140px] bg-emerald-500 text-white py-3 px-4 rounded-lg hover:bg-emerald-600 hidden">ğŸ“‹ å¤åˆ¶ç»“æœ</button>
            <button id="downloadButton" class="flex-1 min-w-[140px] bg-purple-500 text-white py-3 px-4 rounded-lg hover:bg-purple-600 hidden">â¬‡ï¸ ä¸‹è½½æ–‡ä»¶</button>
            <button id="showDetailsButton" class="flex-1 min-w-[140px] bg-amber-500 text-white py-3 px-4 rounded-lg hover:bg-amber-600 hidden">ğŸ” æŸ¥çœ‹è¯¦æƒ…</button>
        </div>
        
        <div id="detailsModal" class="hidden fixed inset-0 flex items-center justify-center z-50">
            <div class="absolute inset-0 bg-black bg-opacity-50" id="modalBackdrop"></div>
            <div class="glass rounded-xl p-6 max-w-lg w-full mx-4 relative z-10">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-bold text-gray-800">AES-256-GCM åŠ è§£å¯†è¯¦æƒ…</h3>
                    <button id="closeModal" class="text-gray-500 hover:text-gray-700 text-2xl">âœ•</button>
                </div>
                <div class="space-y-3">
                    <div><span class="text-sm text-gray-600">ç‰ˆæœ¬ï¼š</span><span id="modalVersion" class="text-sm font-mono">4</span></div>
                    <div><span class="text-sm text-gray-600">è¿­ä»£æ¬¡æ•°ï¼š</span><span id="modalIterations" class="text-sm font-mono">-</span></div>
                    <div><span class="text-sm text-gray-600">MIMEç±»å‹ï¼š</span><span id="modalMime" class="text-sm font-mono">-</span></div>
                    <div><span class="text-sm text-gray-600">IVï¼ˆ12å­—èŠ‚ï¼‰ï¼š</span><span id="modalIV" class="text-sm font-mono break-all">-</span></div>
                    <div><span class="text-sm text-gray-600">ç›å€¼ï¼ˆ16å­—èŠ‚ï¼‰ï¼š</span><span id="modalSalt" class="text-sm font-mono break-all">-</span></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const CURRENT_VERSION = 4;
        const MAGIC_BYTE = 0xE2;
        const SEPARATOR_BYTE = 0x00;
        const MAX_MIME_LEN = 255;
        const customAlphabet = 'ã‚ã„ã†ãˆãŠã‹ããã‘ã“ã•ã—ã™ã›ããŸã¡ã¤ã¦ã¨ãªã«ã¬ã­ã®ã¯ã²ãµã¸ã»ã¾ã¿ã‚€ã‚ã‚‚ã‚„ã‚†ã‚ˆã‚‰ã‚Šã‚‹ã‚Œã‚ã‚ã‚ã‚‘ã‚’ã‚“ã‚¢ã‚¤ã‚¦ã‚¨ã‚ªã‚«ã‚­ã‚¯ã‚±ã‚³ã‚µã‚·ã‚¹ã‚»ã‚½ã‚¿';
        const paddingChar = 'ãƒ³';

        if (customAlphabet.length !== 64) throw new Error('å­—æ¯è¡¨å¿…é¡»64ä½');

        const encodeMap = new Map();
        const decodeMap = new Map();
        for (let i = 0; i < 64; i++) {
            encodeMap.set(i, customAlphabet[i]);
            decodeMap.set(customAlphabet[i], i);
        }

        function customBaseEncode(bytes) {
            let out = '';
            for (let i = 0; i < bytes.length; i += 3) {
                const b1 = bytes[i];
                const b2 = i + 1 < bytes.length ? bytes[i + 1] : 0;
                const b3 = i + 2 < bytes.length ? bytes[i + 2] : 0;
                const e1 = b1 >> 2;
                const e2 = ((b1 & 3) << 4) | (b2 >> 4);
                const e3 = ((b2 & 15) << 2) | (b3 >> 6);
                const e4 = b3 & 63;
                if (i + 1 >= bytes.length) out += encodeMap.get(e1) + encodeMap.get(e2) + paddingChar + paddingChar;
                else if (i + 2 >= bytes.length) out += encodeMap.get(e1) + encodeMap.get(e2) + encodeMap.get(e3) + paddingChar;
                else out += encodeMap.get(e1) + encodeMap.get(e2) + encodeMap.get(e3) + encodeMap.get(e4);
            }
            return out;
        }

        function customBaseDecode(str) {
            if (str.length % 4 !== 0) throw new Error('å¯†æ–‡é•¿åº¦å¿…é¡»ä¸º4çš„å€æ•°');
            const padIndex = str.indexOf(paddingChar);
            if (padIndex !== -1 && !str.slice(padIndex).match(/^ãƒ³{0,2}$/)) {
                throw new Error('éæ³•å¯†æ–‡ï¼špaddingé”™è¯¯');
            }
            let padding = 0;
            if (str.endsWith(paddingChar + paddingChar)) padding = 2;
            else if (str.endsWith(paddingChar)) padding = 1;
            const outLen = (str.length / 4) * 3 - padding;
            const out = new Uint8Array(outLen);
            let outIdx = 0;
            for (let i = 0; i < str.length; i += 4) {
                const c1 = decodeMap.get(str[i]);
                const c2 = decodeMap.get(str[i+1]);
                const c3 = str[i+2] === paddingChar ? 0 : decodeMap.get(str[i+2]);
                const c4 = str[i+3] === paddingChar ? 0 : decodeMap.get(str[i+3]);
                if (c1 === undefined || c2 === undefined ||
                    (str[i+2] !== paddingChar && c3 === undefined) ||
                    (str[i+3] !== paddingChar && c4 === undefined)) {
                    throw new Error(`å¯†æ–‡åŒ…å«éæ³•å­—ç¬¦ï¼ˆä½ç½®çº¦${i+1}ï¼‰`);
                }
                if (outIdx < outLen) out[outIdx++] = (c1 << 2) | (c2 >> 4);
                if (outIdx < outLen) out[outIdx++] = ((c2 & 15) << 4) | (c3 >> 2);
                if (outIdx < outLen) out[outIdx++] = ((c3 & 3) << 6) | c4;
            }
            return out;
        }

        function hexToUint8(hex) {
            const arr = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                arr[i/2] = parseInt(hex.substr(i, 2), 16);
            }
            return arr;
        }

        async function deriveKey(password, salt, iterations) {
            const enc = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                "raw",
                enc.encode(password),
                "PBKDF2",
                false,
                ["deriveKey"]
            );
            return await crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: iterations,
                    hash: "SHA-256"
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                false,
                ["encrypt", "decrypt"]
            );
        }

        function evaluateKeyStrength(pass) {
            if (!pass) return { percent: 0, text: 'æ— ', color: 'text-red-600' };
            let score = 0;
            if (pass.length >= 12) score += 25;
            if (pass.length >= 20) score += 15;
            if (/[a-z]/.test(pass)) score += 15;
            if (/[A-Z]/.test(pass)) score += 15;
            if (/[0-9]/.test(pass)) score += 15;
            if (/[^a-zA-Z0-9]/.test(pass)) score += 15;
            const texts = ['æå¼±', 'å¼±', 'ä¸­ç­‰', 'è¾ƒå¼º', 'å¼º', 'æå¼º'];
            const colors = ['text-red-600', 'text-orange-600', 'text-yellow-600', 'text-green-500', 'text-green-600', 'text-green-700'];
            const idx = Math.min(5, Math.floor(score / 20));
            return { percent: Math.max(10, score), text: texts[idx], color: colors[idx] };
        }

        function getTimestampFilename(base, ext) {
            const now = new Date();
            const yyyy = now.getFullYear();
            const mm = String(now.getMonth() + 1).padStart(2, '0');
            const dd = String(now.getDate()).padStart(2, '0');
            const hh = String(now.getHours()).padStart(2, '0');
            const min = String(now.getMinutes()).padStart(2, '0');
            const ss = String(now.getSeconds()).padStart(2, '0');
            return `${base}_${yyyy}${mm}${dd}_${hh}${min}${ss}${ext}`;
        }

        function getExtensionFromMime(mime) {
            const map = {
                'text/plain': '.txt',
                'text/html': '.html',
                'text/css': '.css',
                'text/javascript': '.js',
                'application/json': '.json',
                'image/jpeg': '.jpg',
                'image/png': '.png',
                'image/gif': '.gif',
                'image/webp': '.webp',
                'image/svg+xml': '.svg',
                'application/pdf': '.pdf',
                'application/zip': '.zip',
                'application/x-rar-compressed': '.rar',
                'video/mp4': '.mp4',
                'audio/mpeg': '.mp3'
            };
            return map[mime] || '.bin';
        }

        function isLikelyText(bytes) {
            try {
                const decoded = new TextDecoder('utf-8', { fatal: true }).decode(bytes.subarray(0, Math.min(1024, bytes.length)));
                return !/[\x00-\x08\x0E-\x1F]/.test(decoded);
            } catch {
                return false;
            }
        }

        function looksLikeCustomBase(str) {
            return /^[ã‚-ã‚“ã‚¢ã‚¤ã‚¦ã‚¨ã‚ªã‚«ã‚­ã‚¯ã‚±ã‚³ã‚µã‚·ã‚¹ã‚»ã‚½ã‚¿ãƒãƒ„ãƒ†ãƒˆãƒ³\s\r\n\t]*$/.test(str);
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function formatTime(seconds) {
            if (seconds < 60) return Math.round(seconds) + ' ç§’';
            if (seconds < 3600) return Math.round(seconds / 60) + ' åˆ†é’Ÿ';
            return Math.round(seconds / 3600) + ' å°æ—¶';
        }

        class App {
            constructor() {
                this.mode = 'encrypt';
                this.isProcessing = false;
                this.lastResult = null;
                this.lastOutputBytes = null;
                this.lastMime = 'application/octet-stream';
                this.lastFileName = '';
                this.importedFile = null;
                this.inputMime = 'application/octet-stream';
                this.processStartTime = 0;
                this.processedBytes = 0;
                this.totalBytes = 0;
                this.initElements();
                this.bindEvents();
                this.setupDragAndDrop();
                this.updateUI();
            }

            initElements() {
                this.el = {
                    useCustomKey: document.getElementById('useCustomKey'),
                    keyInputContainer: document.getElementById('keyInputContainer'),
                    keyInput: document.getElementById('keyInput'),
                    toggleKeyVisibility: document.getElementById('toggleKeyVisibility'),
                    keyStrengthBar: document.getElementById('keyStrengthBar'),
                    keyStrengthText: document.getElementById('keyStrengthText'),
                    inputText: document.getElementById('inputText'),
                    inputLabel: document.getElementById('inputLabel'),
                    charCount: document.getElementById('charCount'),
                    inputInfo: document.getElementById('inputInfo'),
                    importFile: document.getElementById('importFile'),
                    outputText: document.getElementById('outputText'),
                    outputImage: document.getElementById('outputImage'),
                    outputContainer: document.getElementById('outputContainer'),
                    outputLabel: document.getElementById('outputLabel'),
                    encryptButton: document.getElementById('encryptButton'),
                    decryptButton: document.getElementById('decryptButton'),
                    clearButton: document.getElementById('clearButton'),
                    copyButton: document.getElementById('copyButton'),
                    copyAllButton: document.getElementById('copyAllButton'),
                    downloadButton: document.getElementById('downloadButton'),
                    showDetailsButton: document.getElementById('showDetailsButton'),
                    modeText: document.getElementById('modeText'),
                    loadingSpinner: document.getElementById('loadingSpinner'),
                    operationStatus: document.getElementById('operationStatus'),
                    dataSize: document.getElementById('dataSize'),
                    processingTime: document.getElementById('processingTime'),
                    toggleAdvanced: document.getElementById('toggleAdvanced'),
                    advancedOptions: document.getElementById('advancedOptions'),
                    saltInput: document.getElementById('saltInput'),
                    iterationsInput: document.getElementById('iterationsInput'),
                    outputFormat: document.getElementById('outputFormat'),
                    chunkSize: document.getElementById('chunkSize'),
                    detailsModal: document.getElementById('detailsModal'),
                    modalBackdrop: document.getElementById('modalBackdrop'),
                    closeModal: document.getElementById('closeModal'),
                    modalVersion: document.getElementById('modalVersion'),
                    modalIterations: document.getElementById('modalIterations'),
                    modalMime: document.getElementById('modalMime'),
                    modalIV: document.getElementById('modalIV'),
                    modalSalt: document.getElementById('modalSalt'),
                    dragOverlay: document.getElementById('dragOverlay'),
                    processProgress: document.getElementById('processProgress'),
                    progressFill: document.getElementById('progressFill'),
                    progressPercent: document.getElementById('progressPercent'),
                    processedSize: document.getElementById('processedSize'),
                    totalSize: document.getElementById('totalSize'),
                    remainingTime: document.getElementById('remainingTime')
                };
            }

            bindEvents() {
                this.el.useCustomKey.addEventListener('change', () => this.toggleKeyInput());
                this.el.keyInput.addEventListener('input', () => this.updateKeyStrength());
                this.el.toggleKeyVisibility.addEventListener('click', () => this.toggleKeyVisibility());
                this.el.inputText.addEventListener('input', () => this.updateCharCount());
                this.el.importFile.addEventListener('change', (e) => this.handleFileImport(e));
                this.el.encryptButton.addEventListener('click', () => this.handleEncrypt());
                this.el.decryptButton.addEventListener('click', () => this.handleDecrypt());
                this.el.clearButton.addEventListener('click', () => this.handleClear());
                this.el.copyButton.addEventListener('click', () => this.copyResult());
                this.el.copyAllButton.addEventListener('click', () => this.copyAll());
                this.el.downloadButton.addEventListener('click', () => this.downloadResult());
                this.el.showDetailsButton.addEventListener('click', () => this.showDetails());
                this.el.toggleAdvanced.addEventListener('click', () => this.toggleAdvanced());
                this.el.closeModal.addEventListener('click', () => this.hideDetails());
                this.el.modalBackdrop.addEventListener('click', () => this.hideDetails());
            }

            setupDragAndDrop() {
                const body = document.body;
                body.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    this.el.dragOverlay.style.display = 'flex';
                });
                body.addEventListener('dragleave', (e) => {
                    if (!body.contains(e.relatedTarget)) {
                        this.el.dragOverlay.style.display = 'none';
                    }
                });
                body.addEventListener('drop', (e) => {
                    e.preventDefault();
                    this.el.dragOverlay.style.display = 'none';
                    if (e.dataTransfer.files.length > 0) {
                        const file = e.dataTransfer.files[0];
                        this.importedFile = file;
                        this.inputMime = file.type || 'application/octet-stream';
                        this.el.inputText.value = '';
                        this.el.charCount.textContent = '';
                        this.el.inputInfo.textContent = `å·²æ‹–å…¥å¯¼å…¥ï¼š${file.name} (${formatBytes(file.size)})`;
                    }
                });
            }

            toggleKeyInput() {
                this.el.keyInputContainer.classList.toggle('hidden', !this.el.useCustomKey.checked);
                this.updateKeyStrength();
            }

            toggleKeyVisibility() {
                const type = this.el.keyInput.type === 'password' ? 'text' : 'password';
                this.el.keyInput.type = type;
                this.el.toggleKeyVisibility.textContent = type === 'password' ? 'ğŸ‘ï¸' : 'ğŸ™ˆ';
            }

            updateKeyStrength() {
                const pass = this.el.useCustomKey.checked ? this.el.keyInput.value : '';
                const strength = evaluateKeyStrength(pass);
                this.el.keyStrengthBar.style.width = strength.percent + '%';
                this.el.keyStrengthText.textContent = `å¼ºåº¦ï¼š${strength.text}`;
                this.el.keyStrengthText.className = `ml-2 text-xs font-medium ${strength.color}`;
            }

            updateCharCount() {
                const len = this.el.inputText.value.length;
                this.el.charCount.textContent = `${len} å­—ç¬¦`;
            }

            handleFileImport(e) {
                const file = e.target.files[0];
                if (!file) {
                    this.importedFile = null;
                    this.inputMime = 'application/octet-stream';
                    this.el.inputInfo.textContent = '';
                    return;
                }
                this.importedFile = file;
                this.inputMime = file.type || 'application/octet-stream';
                this.el.inputText.value = '';
                this.el.charCount.textContent = '';
                this.el.inputInfo.textContent = `å·²å¯¼å…¥ï¼š${file.name} (${formatBytes(file.size)})`;
            }

            toggleAdvanced() {
                const hidden = this.el.advancedOptions.classList.toggle('hidden');
                this.el.toggleAdvanced.textContent = hidden ? 'æ˜¾ç¤ºé«˜çº§é€‰é¡¹' : 'éšè—é«˜çº§é€‰é¡¹';
            }

            showLoading() {
                this.el.loadingSpinner.style.display = 'block';
                this.isProcessing = true;
                this.el.operationStatus.textContent = 'å¤„ç†ä¸­...';
                this.el.operationStatus.classList.add('processing');
                this.updateUI();
            }

            hideLoading() {
                this.el.loadingSpinner.style.display = 'none';
                this.isProcessing = false;
                this.el.operationStatus.classList.remove('processing');
                this.updateUI();
            }

            updateProgress(processed, total) {
                const percent = Math.round((processed / total) * 100);
                this.el.progressFill.style.width = percent + '%';
                this.el.progressPercent.textContent = percent + '%';
                this.el.processedSize.textContent = formatBytes(processed);
                this.el.totalSize.textContent = formatBytes(total);
                
                const elapsed = (performance.now() - this.processStartTime) / 1000;
                const speed = processed / elapsed;
                const remaining = (total - processed) / speed;
                this.el.remainingTime.textContent = remaining > 0 && isFinite(remaining) ? formatTime(remaining) : 'è®¡ç®—ä¸­...';
            }

            updateUI() {
                this.el.modeText.textContent = this.mode === 'encrypt' ? 'å½“å‰æ¨¡å¼ï¼šåŠ å¯†' : 'å½“å‰æ¨¡å¼ï¼šè§£å¯†';
                this.el.inputLabel.textContent = this.mode === 'encrypt' ? 'è¾“å…¥æ˜æ–‡æˆ–ä»»æ„æ–‡ä»¶' : 'è¾“å…¥å¯†æ–‡æˆ–å¯¼å…¥.enc';
                this.el.outputLabel.textContent = this.mode === 'encrypt' ? 'å¯†æ–‡ç»“æœ' : 'æ˜æ–‡/æ–‡ä»¶ç»“æœ';
                [this.el.encryptButton, this.el.decryptButton, this.el.clearButton].forEach(b => b.disabled = this.isProcessing);
            }

            getPassword() {
                if (this.el.useCustomKey.checked) {
                    if (!this.el.keyInput.value.trim()) throw new Error('å·²å¯ç”¨è‡ªå®šä¹‰å¯†é’¥ä½†æœªè¾“å…¥å¯†ç ');
                    return this.el.keyInput.value.trim();
                }
                return 'z7jgX9RwezqpY588dRphLRMTE3ie2uTX';
            }

            getSalt() {
                const val = this.el.saltInput.value.trim();
                if (val) {
                    if (!/^[0-9a-fA-F]+$/.test(val) || val.length % 2 !== 0) throw new Error('ç›å€¼å¿…é¡»ä¸ºæœ‰æ•ˆåå…­è¿›åˆ¶å­—ç¬¦ä¸²');
                    return hexToUint8(val);
                }
                return crypto.getRandomValues(new Uint8Array(16));
            }

            getIterations() {
                return Math.max(1000, Math.min(1000000, parseInt(this.el.iterationsInput.value) || 200000));
            }

            getChunkSize() {
                return Math.max(1, Math.min(100, parseInt(this.el.chunkSize.value) || 10)) * 1024 * 1024;
            }

            async getInputBytes() {
                if (this.importedFile) {
                    return this.importedFile;
                }
                const text = this.el.inputText.value.trim();
                if (!text) throw new Error('è¯·è¾“å…¥å†…å®¹æˆ–å¯¼å…¥æ–‡ä»¶');
                return new TextEncoder().encode(text);
            }

            displayOutput(bytes, mimeType) {
                this.el.outputText.classList.add('hidden');
                this.el.outputImage.classList.add('hidden');
                const isImage = mimeType.startsWith('image/');
                let isText = mimeType.startsWith('text/') || isLikelyText(bytes);
                if (isImage) {
                    const blob = new Blob([bytes], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    this.el.outputImage.src = url;
                    this.el.outputImage.classList.remove('hidden');
                    this.el.downloadButton.classList.remove('hidden');
                    this.el.copyButton.classList.add('hidden');
                } else if (isText) {
                    const text = new TextDecoder('utf-8').decode(bytes);
                    this.el.outputText.value = text;
                    this.el.outputText.classList.remove('hidden');
                    this.el.copyButton.classList.remove('hidden');
                    this.el.downloadButton.classList.remove('hidden');
                } else {
                    this.el.outputText.value = '[äºŒè¿›åˆ¶æ–‡ä»¶å·²è§£å¯†ï¼Œè¯·ç‚¹å‡»ä¸‹è½½ä¿å­˜]';
                    this.el.outputText.classList.remove('hidden');
                    this.el.downloadButton.classList.remove('hidden');
                    this.el.copyButton.classList.add('hidden');
                }
                this.el.showDetailsButton.classList.remove('hidden');
            }

            downloadResult() {
                if (!this.lastOutputBytes) return;
                const blob = new Blob([this.lastOutputBytes], { type: this.lastMime });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = this.lastFileName;
                a.click();
                URL.revokeObjectURL(url);
            }

            async handleEncrypt() {
                if (this.isProcessing) return;
                this.mode = 'encrypt';
                this.updateUI();
                this.processStartTime = performance.now();
                
                try {
                    this.showLoading();
                    this.el.processProgress.classList.add('active');
                    
                    const input = await this.getInputBytes();
                    const isFile = input instanceof File;
                    const fileSize = isFile ? input.size : input.length;
                    
                    const password = this.getPassword();
                    const salt = this.getSalt();
                    const iterations = this.getIterations();
                    const chunkSize = this.getChunkSize();
                    const iv = crypto.getRandomValues(new Uint8Array(12));
                    const key = await deriveKey(password, salt, iterations);

                    const mimeBytes = new TextEncoder().encode(this.inputMime);
                    let mimeLen = Math.min(mimeBytes.length, MAX_MIME_LEN);

                    const header = new Uint8Array(1 + 1 + 1 + 4 + 16 + 12 + mimeLen + 1);
                    let pos = 0;
                    header[pos++] = MAGIC_BYTE;
                    header[pos++] = CURRENT_VERSION;
                    header[pos++] = mimeLen;
                    new DataView(header.buffer).setUint32(pos, iterations, false);
                    pos += 4;
                    header.set(salt, pos); pos += 16;
                    header.set(iv, pos); pos += 12;
                    header.set(mimeBytes.slice(0, mimeLen), pos); pos += mimeLen;
                    header[pos++] = SEPARATOR_BYTE;

                    this.totalBytes = fileSize;
                    this.processedBytes = 0;
                    this.updateProgress(0, fileSize);

                    let chunks = [];
                    let offset = 0;

                    while (offset < fileSize) {
                        const end = Math.min(offset + chunkSize, fileSize);
                        let chunk;
                        
                        if (isFile) {
                            const slice = input.slice(offset, end);
                            chunk = new Uint8Array(await slice.arrayBuffer());
                        } else {
                            chunk = input.slice(offset, end);
                        }

                        const encrypted = await crypto.subtle.encrypt(
                            { name: "AES-GCM", iv: iv },
                            key,
                            chunk
                        );
                        
                        chunks.push(new Uint8Array(encrypted));
                        offset = end;
                        this.processedBytes = offset;
                        this.updateProgress(this.processedBytes, this.totalBytes);
                        
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }

                    const totalEncryptedSize = chunks.reduce((sum, c) => sum + c.length, 0);
                    const combined = new Uint8Array(header.length + totalEncryptedSize);
                    combined.set(header, 0);
                    let combinedOffset = header.length;
                    for (const chunk of chunks) {
                        combined.set(chunk, combinedOffset);
                        combinedOffset += chunk.length;
                    }

                    const outputFormat = this.el.outputFormat.value;
                    let outputBytes, mime, fileName;
                    
                    if (outputFormat === 'base' && combined.length < 50 * 1024 * 1024) {
                        const text = customBaseEncode(combined);
                        this.el.outputText.value = text.substring(0, 10000) + (text.length > 10000 ? '\n\n... (å†…å®¹è¿‡é•¿ï¼Œå·²æˆªæ–­æ˜¾ç¤ºï¼Œå®Œæ•´å†…å®¹è¯·ä¸‹è½½)' : '');
                        this.el.outputText.classList.remove('hidden');
                        outputBytes = new TextEncoder().encode(text);
                        mime = 'text/plain;charset=utf-8';
                        fileName = this.importedFile ? this.importedFile.name + '.enc.txt' : getTimestampFilename('encrypted', '.enc.txt');
                        this.el.copyButton.classList.remove('hidden');
                    } else {
                        if (outputFormat === 'base') {
                            this.showMessage('æ–‡ä»¶è¿‡å¤§ï¼Œå·²è‡ªåŠ¨åˆ‡æ¢ä¸ºäºŒè¿›åˆ¶æ ¼å¼', 'info');
                        }
                        this.el.outputText.value = '[äºŒè¿›åˆ¶åŠ å¯†æ–‡ä»¶å·²ç”Ÿæˆï¼Œè¯·ç‚¹å‡»ä¸‹è½½]';
                        this.el.outputText.classList.remove('hidden');
                        outputBytes = combined;
                        mime = 'application/octet-stream';
                        fileName = this.importedFile ? this.importedFile.name + '.enc' : getTimestampFilename('encrypted', '.enc');
                    }

                    this.lastOutputBytes = outputBytes;
                    this.lastMime = mime;
                    this.lastFileName = fileName;
                    this.lastResult = {
                        version: CURRENT_VERSION,
                        iterations,
                        mime: this.inputMime,
                        iv: Array.from(iv).map(b => b.toString(16).padStart(2,'0')).join(''),
                        salt: Array.from(salt).map(b => b.toString(16).padStart(2,'0')).join('')
                    };

                    const elapsed = Math.round(performance.now() - this.processStartTime);
                    this.el.dataSize.textContent = formatBytes(combined.length);
                    this.el.processingTime.textContent = `${(elapsed/1000).toFixed(2)} ç§’`;
                    this.el.operationStatus.textContent = 'âœ“ åŠ å¯†æˆåŠŸ';
                    this.el.operationStatus.className = 'text-green-600 font-medium';
                    this.el.downloadButton.classList.remove('hidden');
                    this.el.showDetailsButton.classList.remove('hidden');
                    this.showMessage('åŠ å¯†æˆåŠŸï¼', 'success');
                } catch (e) {
                    console.error(e);
                    this.el.operationStatus.textContent = 'âœ— åŠ å¯†å¤±è´¥';
                    this.el.operationStatus.className = 'text-red-600 font-medium';
                    this.showMessage('åŠ å¯†å¤±è´¥ï¼š' + e.message, 'error');
                } finally {
                    this.hideLoading();
                    this.el.processProgress.classList.remove('active');
                }
            }

            async handleDecrypt() {
                if (this.isProcessing) return;
                this.mode = 'decrypt';
                this.updateUI();
                this.processStartTime = performance.now();
                
                try {
                    this.showLoading();
                    this.el.processProgress.classList.add('active');
                    
                    let combined;
                    if (this.importedFile) {
                        const fileSize = this.importedFile.size;
                        this.totalBytes = fileSize;
                        this.processedBytes = 0;
                        this.updateProgress(0, fileSize);

                        const chunkSize = this.getChunkSize();
                        const chunks = [];
                        let offset = 0;

                        while (offset < fileSize) {
                            const end = Math.min(offset + chunkSize, fileSize);
                            const slice = this.importedFile.slice(offset, end);
                            const chunk = new Uint8Array(await slice.arrayBuffer());
                            chunks.push(chunk);
                            offset = end;
                            this.processedBytes = offset;
                            this.updateProgress(this.processedBytes, this.totalBytes);
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }

                        const totalSize = chunks.reduce((sum, c) => sum + c.length, 0);
                        combined = new Uint8Array(totalSize);
                        let combinedOffset = 0;
                        for (const chunk of chunks) {
                            combined.set(chunk, combinedOffset);
                            combinedOffset += chunk.length;
                        }

                        if (!(combined.length > 1 && combined[0] === MAGIC_BYTE && combined[1] === CURRENT_VERSION)) {
                            const text = new TextDecoder().decode(combined);
                            if (looksLikeCustomBase(text)) {
                                combined = customBaseDecode(text.trim());
                            } else {
                                throw new Error('æ— æ³•è¯†åˆ«çš„æ–‡ä»¶æ ¼å¼');
                            }
                        }
                    } else {
                        const input = this.el.inputText.value.trim();
                        if (!input) throw new Error('è¯·è¾“å…¥å¯†æ–‡æˆ–å¯¼å…¥æ–‡ä»¶');
                        combined = customBaseDecode(input);
                    }

                    if (combined.length < 61) throw new Error('å¯†æ–‡å¤ªçŸ­ï¼Œå¯èƒ½å·²æŸå');
                    let offset = 0;
                    if (combined[offset++] !== MAGIC_BYTE) throw new Error('éæ³•å¯†æ–‡ï¼šmagic byteé”™è¯¯');
                    const version = combined[offset++];
                    if (version !== CURRENT_VERSION) throw new Error(`ä¸æ”¯æŒçš„ç‰ˆæœ¬ï¼š${version}ï¼ˆå½“å‰å·¥å…·æ”¯æŒç‰ˆæœ¬${CURRENT_VERSION}ï¼‰`);

                    const mimeLen = combined[offset++];
                    const iterations = new DataView(combined.buffer, combined.byteOffset + offset, 4).getUint32(0, false);
                    offset += 4;
                    const salt = combined.slice(offset, offset + 16); offset += 16;
                    const iv = combined.slice(offset, offset + 12); offset += 12;

                    const mimeType = mimeLen > 0 ? new TextDecoder().decode(combined.slice(offset, offset + mimeLen)) : 'application/octet-stream';
                    offset += mimeLen;

                    if (combined[offset++] !== SEPARATOR_BYTE) {
                        throw new Error('å¯†æ–‡ç»“æ„é”™è¯¯ï¼šMIMEåˆ†éš”ç¬¦ç¼ºå¤±æˆ–æŸå');
                    }

                    const ciphertextWithTag = combined.slice(offset);
                    if (ciphertextWithTag.length < 16) throw new Error('å¯†æ–‡æ•°æ®è¿‡çŸ­');

                    const password = this.getPassword();
                    const key = await deriveKey(password, salt, iterations);

                    this.totalBytes = ciphertextWithTag.length;
                    this.processedBytes = 0;
                    this.updateProgress(0, this.totalBytes);

                    const decrypted = await crypto.subtle.decrypt(
                        { name: "AES-GCM", iv: iv },
                        key,
                        ciphertextWithTag
                    );

                    this.processedBytes = this.totalBytes;
                    this.updateProgress(this.processedBytes, this.totalBytes);

                    const plaintextBytes = new Uint8Array(decrypted);

                    this.displayOutput(plaintextBytes, mimeType);

                    let baseName = 'decrypted';
                    if (this.importedFile) {
                        baseName = this.importedFile.name
                            .replace(/\.enc\.txt$/i, '')
                            .replace(/\.enc$/i, '');
                    }

                    let ext = getExtensionFromMime(mimeType);
                    if (mimeType === 'application/octet-stream' && isLikelyText(plaintextBytes)) {
                        ext = '.txt';
                    }

                    if (/\.\w+$/.test(baseName)) {
                        this.lastFileName = baseName;
                    } else {
                        this.lastFileName = baseName + ext;
                    }

                    this.lastOutputBytes = plaintextBytes;
                    this.lastMime = mimeType;
                    this.lastResult = {
                        version: CURRENT_VERSION,
                        iterations,
                        mime: mimeType,
                        iv: Array.from(iv).map(b=>b.toString(16).padStart(2,'0')).join(''),
                        salt: Array.from(salt).map(b=>b.toString(16).padStart(2,'0')).join('')
                    };

                    const elapsed = Math.round(performance.now() - this.processStartTime);
                    this.el.dataSize.textContent = formatBytes(combined.length);
                    this.el.processingTime.textContent = `${(elapsed/1000).toFixed(2)} ç§’`;
                    this.el.operationStatus.textContent = 'âœ“ è§£å¯†æˆåŠŸ';
                    this.el.operationStatus.className = 'text-green-600 font-medium';
                    this.showMessage('è§£å¯†æˆåŠŸï¼', 'success');
                } catch (e) {
                    console.error(e);
                    this.el.operationStatus.textContent = 'âœ— è§£å¯†å¤±è´¥';
                    this.el.operationStatus.className = 'text-red-600 font-medium';
                    this.showMessage('è§£å¯†å¤±è´¥ï¼š' + e.message, 'error');
                } finally {
                    this.hideLoading();
                    this.el.processProgress.classList.remove('active');
                }
            }

            handleClear() {
                this.el.useCustomKey.checked = false;
                this.el.keyInput.value = '';
                this.el.saltInput.value = '';
                this.el.iterationsInput.value = 200000;
                this.el.outputFormat.value = 'base';
                this.el.chunkSize.value = 10;
                this.el.inputText.value = '';
                this.el.outputText.value = '';
                this.el.outputImage.src = '';
                this.el.outputText.classList.add('hidden');
                this.el.outputImage.classList.add('hidden');
                this.el.charCount.textContent = '0 å­—ç¬¦';
                this.el.dataSize.textContent = '-';
                this.el.processingTime.textContent = '-';
                this.el.operationStatus.textContent = 'å°±ç»ª';
                this.el.operationStatus.className = 'text-gray-800';
                this.el.inputInfo.textContent = '';
                this.el.importFile.value = '';
                this.importedFile = null;
                this.inputMime = 'application/octet-stream';
                this.lastOutputBytes = null;
                this.el.processProgress.classList.remove('active');
                [this.el.copyButton, this.el.copyAllButton, this.el.downloadButton, this.el.showDetailsButton].forEach(b => b.classList.add('hidden'));
                this.toggleKeyInput();
                this.el.advancedOptions.classList.add('hidden');
                this.el.toggleAdvanced.textContent = 'æ˜¾ç¤ºé«˜çº§é€‰é¡¹';
                this.showMessage('å·²æ¸…ç©º', 'info');
            }

            copyResult() {
                navigator.clipboard.writeText(this.el.outputText.value).then(() => this.showMessage('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success'));
            }

            copyAll() {
                navigator.clipboard.writeText(this.el.outputText.value).then(() => this.showMessage('å·²å¤åˆ¶å…¨éƒ¨å†…å®¹', 'success'));
            }

            showDetails() {
                if (!this.lastResult) return;
                this.el.modalVersion.textContent = this.lastResult.version;
                this.el.modalIterations.textContent = this.lastResult.iterations;
                this.el.modalMime.textContent = this.lastResult.mime;
                this.el.modalIV.textContent = this.lastResult.iv;
                this.el.modalSalt.textContent = this.lastResult.salt;
                this.el.detailsModal.classList.remove('hidden');
            }

            hideDetails() {
                this.el.detailsModal.classList.add('hidden');
            }

            showMessage(msg, type = 'info') {
                const el = document.createElement('div');
                el.className = `fixed top-4 right-4 px-6 py-3 rounded-lg shadow-lg z-50 text-white font-medium`;
                el.className += type === 'success' ? ' bg-green-600' : type === 'error' ? ' bg-red-600' : ' bg-blue-600';
                el.textContent = msg;
                document.body.appendChild(el);
                setTimeout(() => {
                    el.style.opacity = '0';
                    el.style.transition = 'opacity 0.5s';
                    setTimeout(() => el.remove(), 500);
                }, 3000);
            }
        }

        document.addEventListener('DOMContentLoaded', () => new App());
    </script>
</body>
</html>
