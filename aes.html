<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AES-256-CTR+HMAC åŠ è§£å¯†å·¥å…·ï¼ˆæ”¯æŒå¤§æ–‡ä»¶ï¼‰</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- å¿…é¡»å…ˆåŠ è½½ hash-wasm UMD ç‰ˆæœ¬ -->
    <script src="https://cdn.jsdelivr.net/npm/hash-wasm@4/dist/hmac.umd.min.js"></script>

    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            background-attachment: fixed;
            min-height: 100vh;
        }
        .glass {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .loading {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #e5e7eb;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
        }
        .progress-fill {
            height: 100%;
            background: #3b82f6;
            width: 0%;
            transition: width 0.3s ease;
        }
        #dragOverlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(59, 130, 246, 0.3);
            backdrop-filter: blur(4px);
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: white;
            font-weight: bold;
            z-index: 1000;
            pointer-events: none;
        }
        .process-progress {
            display: none;
            margin-top: 1rem;
        }
        .process-progress.active {
            display: block;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .processing {
            animation: pulse 1.5s ease-in-out infinite;
        }
    </style>
</head>
<body class="flex items-center justify-center p-4">
    <div id="dragOverlay">æ‹–å…¥æ–‡ä»¶åˆ°æ­¤å¤„å¯¼å…¥</div>
    
    <div class="glass rounded-xl shadow-2xl p-6 max-w-2xl w-full relative">
        <div id="loadingSpinner" class="loading">
            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
        </div>
        
        <h1 class="text-2xl font-bold text-center text-gray-800 mb-2">ğŸ” AES-256-CTR+HMAC åŠ è§£å¯†å·¥å…·</h1>
        <p class="text-center text-gray-600 text-sm mb-6">çœŸæ­£çš„æµå¼åŠ å¯† Â· æ”¯æŒç™¾GBæ–‡ä»¶ Â· çº¯å‰ç«¯å¤„ç†</p>
        
        <div class="mb-6 text-center">
            <span id="modeIndicator" class="inline-flex items-center px-4 py-2 rounded-full text-sm font-medium bg-blue-100 text-blue-800">
                <span class="w-2 h-2 bg-blue-600 rounded-full mr-2"></span>
                <span id="modeText">å½“å‰æ¨¡å¼ï¼šåŠ å¯†</span>
            </span>
        </div>
        
        <div class="mb-6 bg-gray-50 rounded-lg p-4 border">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-medium text-gray-700">å¯†é’¥è®¾ç½®</h3>
                <button type="button" id="toggleAdvanced" class="text-sm text-blue-600 hover:text-blue-800">
                    æ˜¾ç¤ºé«˜çº§é€‰é¡¹
                </button>
            </div>
            <div class="mb-4">
                <label class="inline-flex items-center">
                    <input id="useCustomKey" type="checkbox" class="form-checkbox h-5 w-5 text-blue-600">
                    <span class="ml-2 text-sm font-medium text-gray-600">å¯ç”¨è‡ªå®šä¹‰å¯†é’¥</span>
                </label>
                <p class="text-xs text-gray-500 ml-7 mt-1">ä¸å¯ç”¨åˆ™ä½¿ç”¨é»˜è®¤å¯†é’¥</p>
            </div>
            <div id="keyInputContainer" class="mb-4 hidden">
                <label class="block text-sm font-medium text-gray-600 mb-1">è¾“å…¥å¯†é’¥/å¯†ç </label>
                <div class="relative">
                    <input id="keyInput" type="password" class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                           placeholder="å»ºè®®12ä½ä»¥ä¸Šï¼Œå«å¤§å°å†™+æ•°å­—+ç¬¦å·">
                    <button type="button" id="toggleKeyVisibility" class="absolute right-3 top-3 text-gray-500 hover:text-gray-700">
                        ğŸ‘ï¸
                    </button>
                </div>
                <div class="flex items-center mt-2">
                    <div class="progress-bar flex-1">
                        <div id="keyStrengthBar" class="progress-fill"></div>
                    </div>
                    <span id="keyStrengthText" class="ml-2 text-xs text-gray-500">å¯†é’¥å¼ºåº¦</span>
                </div>
            </div>
            <div id="advancedOptions" class="hidden space-y-4 mt-4 pt-4 border-t">
                <div>
                    <label class="block text-sm font-medium text-gray-600 mb-1">ç›å€¼ï¼ˆSaltï¼Œå¯é€‰åå…­è¿›åˆ¶ï¼‰</label>
                    <input id="saltInput" type="text" class="w-full p-2 border rounded-md"
                           placeholder="ç•™ç©ºè‡ªåŠ¨ç”Ÿæˆéšæœºç›å€¼">
                    <p class="text-xs text-gray-500 mt-1">è‡ªå®šä¹‰ç›å€¼éœ€åœ¨è§£å¯†æ—¶æ‰‹åŠ¨è¾“å…¥ç›¸åŒå€¼</p>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-600 mb-1">è¿­ä»£æ¬¡æ•°</label>
                    <input id="iterationsInput" type="number" value="200000" min="1000" max="1000000"
                           class="w-full p-2 border rounded-md">
                    <p class="text-xs text-gray-500 mt-1">é»˜è®¤200000ï¼Œæ›´é«˜æ›´å®‰å…¨ä½†é€Ÿåº¦ç¨æ…¢ï¼ˆä¸Šé™1000000ï¼‰</p>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-600 mb-1">åˆ†å—å¤§å°ï¼ˆMBï¼‰</label>
                    <input id="chunkSize" type="number" value="10" min="1" max="100"
                           class="w-full p-2 border rounded-md">
                    <p class="text-xs text-gray-500 mt-1">è¾ƒå°çš„åˆ†å—å¯å‡å°‘å†…å­˜å ç”¨ï¼Œå»ºè®®5-20MB</p>
                </div>
            </div>
        </div>
        
        <div class="mb-6">
            <div class="flex justify-between items-center mb-2">
                <label id="inputLabel" class="block text-sm font-medium text-gray-600">è¾“å…¥æ˜æ–‡æˆ–ä»»æ„æ–‡ä»¶</label>
                <span id="charCount" class="text-sm text-gray-500">0 å­—ç¬¦</span>
            </div>
            <textarea id="inputText" rows="5"
                      class="w-full p-4 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-base"
                      placeholder="åŠ å¯†è¯·è¾“å…¥æ˜æ–‡æˆ–å¯¼å…¥ä»»æ„æ–‡ä»¶ï¼ˆæ”¯æŒç™¾GBçº§åˆ«ï¼‰ï¼Œè§£å¯†è¯·è¾“å…¥å¯†æ–‡æˆ–å¯¼å…¥.encæ–‡ä»¶"></textarea>
            <div class="mt-2">
                <label class="bg-blue-500 text-white px-4 py-2 rounded cursor-pointer hover:bg-blue-600 inline-block">
                    ğŸ“ é€‰æ‹©æ–‡ä»¶ï¼ˆæ”¯æŒä»»æ„å¤§å°ï¼‰ <input type="file" id="importFile" class="hidden" accept="*/*">
                </label>
            </div>
            <p id="inputInfo" class="text-sm text-gray-500 mt-1"></p>
        </div>
        
        <div class="process-progress" id="processProgress">
            <div class="bg-gray-100 rounded-lg p-4 border">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-sm font-medium text-gray-700">å¤„ç†è¿›åº¦</span>
                    <span id="progressPercent" class="text-sm font-medium text-blue-600">0%</span>
                </div>
                <div class="progress-bar h-6">
                    <div id="progressFill" class="progress-fill bg-gradient-to-r from-blue-500 to-purple-500"></div>
                </div>
                <div class="mt-2 text-xs text-gray-600 space-y-1">
                    <div class="flex justify-between">
                        <span>å·²å¤„ç†ï¼š</span>
                        <span id="processedSize" class="font-medium">0 MB</span>
                    </div>
                    <div class="flex justify-between">
                        <span>æ€»å¤§å°ï¼š</span>
                        <span id="totalSize" class="font-medium">0 MB</span>
                    </div>
                    <div class="flex justify-between">
                        <span>é¢„è®¡å‰©ä½™æ—¶é—´ï¼š</span>
                        <span id="remainingTime" class="font-medium">è®¡ç®—ä¸­...</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="flex flex-wrap justify-center gap-3 mb-6">
            <button id="encryptButton" class="flex-1 min-w-[120px] bg-blue-600 text-white py-3 px-4 rounded-lg hover:bg-blue-700 font-medium flex items-center justify-center">
                <span>ğŸ”’</span><span class="ml-2">åŠ å¯†</span>
            </button>
            <button id="decryptButton" class="flex-1 min-w-[120px] bg-green-600 text-white py-3 px-4 rounded-lg hover:bg-green-700 font-medium flex items-center justify-center">
                <span>ğŸ”“</span><span class="ml-2">è§£å¯†</span>
            </button>
            <button id="clearButton" class="flex-1 min-w-[120px] bg-gray-500 text-white py-3 px-4 rounded-lg hover:bg-gray-600 font-medium flex items-center justify-center">
                <span>ğŸ—‘ï¸</span><span class="ml-2">æ¸…ç©º</span>
            </button>
        </div>
        
        <div class="mb-6">
            <div class="flex justify-between items-center mb-2">
                <label id="outputLabel" class="block text-sm font-medium text-gray-600">ç»“æœ</label>
            </div>
            <div id="outputContainer" class="w-full border rounded-lg bg-gray-50 overflow-hidden">
                <textarea id="outputText" rows="5" class="w-full p-4 font-mono text-base hidden" readonly></textarea>
                <img id="outputImage" class="max-w-full h-auto hidden" alt="è§£å¯†å›¾ç‰‡é¢„è§ˆ">
            </div>
            <div id="outputInfo" class="mt-3 space-y-2">
                <div class="flex justify-between text-sm"><span class="text-gray-600">æ“ä½œçŠ¶æ€ï¼š</span><span id="operationStatus" class="text-gray-800">å°±ç»ª</span></div>
                <div class="flex justify-between text-sm"><span class="text-gray-600">æ•°æ®å¤§å°ï¼š</span><span id="dataSize" class="text-gray-800">-</span></div>
                <div class="flex justify-between text-sm"><span class="text-gray-600">å¤„ç†æ—¶é—´ï¼š</span><span id="processingTime" class="text-gray-800">-</span></div>
            </div>
        </div>
        
        <div class="flex flex-wrap justify-center gap-3">
            <button id="copyButton" class="flex-1 min-w-[140px] bg-emerald-500 text-white py-3 px-4 rounded-lg hover:bg-emerald-600 hidden">ğŸ“‹ å¤åˆ¶ç»“æœ</button>
            <button id="downloadButton" class="flex-1 min-w-[140px] bg-purple-500 text-white py-3 px-4 rounded-lg hover:bg-purple-600 hidden">â¬‡ï¸ ä¸‹è½½æ–‡ä»¶</button>
            <button id="showDetailsButton" class="flex-1 min-w-[140px] bg-amber-500 text-white py-3 px-4 rounded-lg hover:bg-amber-600 hidden">ğŸ” æŸ¥çœ‹è¯¦æƒ…</button>
        </div>
        
        <div id="detailsModal" class="hidden fixed inset-0 flex items-center justify-center z-50">
            <div class="absolute inset-0 bg-black bg-opacity-50" id="modalBackdrop"></div>
            <div class="glass rounded-xl p-6 max-w-lg w-full mx-4 relative z-10">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-bold text-gray-800">AES-256-CTR+HMAC åŠ è§£å¯†è¯¦æƒ…</h3>
                    <button id="closeModal" class="text-gray-500 hover:text-gray-700 text-2xl">âœ•</button>
                </div>
                <div class="space-y-3">
                    <div><span class="text-sm text-gray-600">ç‰ˆæœ¬ï¼š</span><span id="modalVersion" class="text-sm font-mono">5</span></div>
                    <div><span class="text-sm text-gray-600">ç®—æ³•ï¼š</span><span class="text-sm font-mono">AES-256-CTR + HMAC-SHA256</span></div>
                    <div><span class="text-sm text-gray-600">è¿­ä»£æ¬¡æ•°ï¼š</span><span id="modalIterations" class="text-sm font-mono">-</span></div>
                    <div><span class="text-sm text-gray-600">MIMEç±»å‹ï¼š</span><span id="modalMime" class="text-sm font-mono">-</span></div>
                    <div><span class="text-sm text-gray-600">IV/Nonceï¼š</span><span id="modalIV" class="text-sm font-mono break-all">-</span></div>
                    <div><span class="text-sm text-gray-600">ç›å€¼ï¼š</span><span id="modalSalt" class="text-sm font-mono break-all">-</span></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        

        const CURRENT_VERSION = 5;
        const MAGIC_BYTE = 0xE2;
        const SEPARATOR_BYTE = 0x00;
        const MAX_MIME_LEN = 255;
        const HMAC_TAG_LEN = 32;

        function hexToUint8(hex) {
            const arr = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                arr[i/2] = parseInt(hex.substr(i, 2), 16);
            }
            return arr;
        }

        async function deriveKeys(password, salt, iterations) {
            const enc = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                "raw",
                enc.encode(password),
                "PBKDF2",
                false,
                ["deriveKey", "deriveBits"]
            );
            
            const derivedBits = await crypto.subtle.deriveBits(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: iterations,
                    hash: "SHA-256"
                },
                keyMaterial,
                512
            );
            
            const derivedBytes = new Uint8Array(derivedBits);
            const aesKeyBytes = derivedBytes.slice(0, 32);
            const hmacKeyBytes = derivedBytes.slice(32, 64);
            
            const aesKey = await crypto.subtle.importKey(
                "raw",
                aesKeyBytes,
                { name: "AES-CTR" },
                false,
                ["encrypt", "decrypt"]
            );
            
            return { aesKey, hmacKeyBytes };
        }

        function evaluateKeyStrength(pass) {
            if (!pass) return { percent: 0, text: 'æ— ', color: 'text-red-600' };
            let score = 0;
            if (pass.length >= 12) score += 25;
            if (pass.length >= 20) score += 15;
            if (/[a-z]/.test(pass)) score += 15;
            if (/[A-Z]/.test(pass)) score += 15;
            if (/[0-9]/.test(pass)) score += 15;
            if (/[^a-zA-Z0-9]/.test(pass)) score += 15;
            const texts = ['æå¼±', 'å¼±', 'ä¸­ç­‰', 'è¾ƒå¼º', 'å¼º', 'æå¼º'];
            const colors = ['text-red-600', 'text-orange-600', 'text-yellow-600', 'text-green-500', 'text-green-600', 'text-green-700'];
            const idx = Math.min(5, Math.floor(score / 20));
            return { percent: Math.max(10, score), text: texts[idx], color: colors[idx] };
        }

        function getTimestampFilename(base, ext) {
            const now = new Date();
            const yyyy = now.getFullYear();
            const mm = String(now.getMonth() + 1).padStart(2, '0');
            const dd = String(now.getDate()).padStart(2, '0');
            const hh = String(now.getHours()).padStart(2, '0');
            const min = String(now.getMinutes()).padStart(2, '0');
            const ss = String(now.getSeconds()).padStart(2, '0');
            return `${base}_${yyyy}${mm}${dd}_${hh}${min}${ss}${ext}`;
        }

        function getExtensionFromMime(mime) {
            const map = {
                'text/plain': '.txt',
                'text/html': '.html',
                'image/jpeg': '.jpg',
                'image/png': '.png',
                'image/gif': '.gif',
                'application/pdf': '.pdf',
                'application/zip': '.zip',
                'video/mp4': '.mp4',
                'audio/mpeg': '.mp3'
            };
            return map[mime] || '.bin';
        }

        function isLikelyText(bytes) {
            try {
                const decoded = new TextDecoder('utf-8', { fatal: true }).decode(bytes.subarray(0, Math.min(1024, bytes.length)));
                return !/[\x00-\x08\x0E-\x1F]/.test(decoded);
            } catch {
                return false;
            }
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function formatTime(seconds) {
            if (seconds < 60) return Math.round(seconds) + ' ç§’';
            if (seconds < 3600) return Math.round(seconds / 60) + ' åˆ†é’Ÿ';
            return Math.round(seconds / 3600) + ' å°æ—¶';
        }

        // æµå¼ HMACï¼Œä½¿ç”¨ window.hashwasm
        class IncrementalHMAC {
            constructor(keyBytes) {
                this.hmac = new window.hashwasm.HmacSha256(keyBytes);
                this.hmac.init();
            }

            update(data) {
                this.hmac.update(data);
            }

            async finalize() {
                const hex = this.hmac.digest('hex');
                const out = new Uint8Array(hex.length / 2);
                for (let i = 0; i < hex.length; i += 2) {
                    out[i >> 1] = parseInt(hex.substr(i, 2), 16);
                }
                return out;
            }
        }

        class App {
            constructor() {
                this.mode = 'encrypt';
                this.isProcessing = false;
                this.lastResult = null;
                this.lastFileName = '';
                this.importedFile = null;
                this.inputMime = 'application/octet-stream';
                this.processStartTime = 0;
                this.processedBytes = 0;
                this.totalBytes = 0;
                this.initElements();
                this.bindEvents();
                this.setupDragAndDrop();
                this.updateUI();
            }

            initElements() {
                this.el = {
                    useCustomKey: document.getElementById('useCustomKey'),
                    keyInputContainer: document.getElementById('keyInputContainer'),
                    keyInput: document.getElementById('keyInput'),
                    toggleKeyVisibility: document.getElementById('toggleKeyVisibility'),
                    keyStrengthBar: document.getElementById('keyStrengthBar'),
                    keyStrengthText: document.getElementById('keyStrengthText'),
                    inputText: document.getElementById('inputText'),
                    inputLabel: document.getElementById('inputLabel'),
                    charCount: document.getElementById('charCount'),
                    inputInfo: document.getElementById('inputInfo'),
                    importFile: document.getElementById('importFile'),
                    outputText: document.getElementById('outputText'),
                    outputImage: document.getElementById('outputImage'),
                    outputLabel: document.getElementById('outputLabel'),
                    encryptButton: document.getElementById('encryptButton'),
                    decryptButton: document.getElementById('decryptButton'),
                    clearButton: document.getElementById('clearButton'),
                    copyButton: document.getElementById('copyButton'),
                    downloadButton: document.getElementById('downloadButton'),
                    showDetailsButton: document.getElementById('showDetailsButton'),
                    modeText: document.getElementById('modeText'),
                    loadingSpinner: document.getElementById('loadingSpinner'),
                    operationStatus: document.getElementById('operationStatus'),
                    dataSize: document.getElementById('dataSize'),
                    processingTime: document.getElementById('processingTime'),
                    toggleAdvanced: document.getElementById('toggleAdvanced'),
                    advancedOptions: document.getElementById('advancedOptions'),
                    saltInput: document.getElementById('saltInput'),
                    iterationsInput: document.getElementById('iterationsInput'),
                    chunkSize: document.getElementById('chunkSize'),
                    detailsModal: document.getElementById('detailsModal'),
                    modalBackdrop: document.getElementById('modalBackdrop'),
                    closeModal: document.getElementById('closeModal'),
                    modalVersion: document.getElementById('modalVersion'),
                    modalIterations: document.getElementById('modalIterations'),
                    modalMime: document.getElementById('modalMime'),
                    modalIV: document.getElementById('modalIV'),
                    modalSalt: document.getElementById('modalSalt'),
                    dragOverlay: document.getElementById('dragOverlay'),
                    processProgress: document.getElementById('processProgress'),
                    progressFill: document.getElementById('progressFill'),
                    progressPercent: document.getElementById('progressPercent'),
                    processedSize: document.getElementById('processedSize'),
                    totalSize: document.getElementById('totalSize'),
                    remainingTime: document.getElementById('remainingTime')
                };
            }

            bindEvents() {
                this.el.useCustomKey.addEventListener('change', () => this.toggleKeyInput());
                this.el.keyInput.addEventListener('input', () => this.updateKeyStrength());
                this.el.toggleKeyVisibility.addEventListener('click', () => this.toggleKeyVisibility());
                this.el.inputText.addEventListener('input', () => this.updateCharCount());
                this.el.importFile.addEventListener('change', (e) => this.handleFileImport(e));
                this.el.encryptButton.addEventListener('click', () => this.handleEncrypt());
                this.el.decryptButton.addEventListener('click', () => this.handleDecrypt());
                this.el.clearButton.addEventListener('click', () => this.handleClear());
                this.el.copyButton.addEventListener('click', () => this.copyResult());
                this.el.downloadButton.addEventListener('click', () => this.downloadResult());
                this.el.showDetailsButton.addEventListener('click', () => this.showDetails());
                this.el.toggleAdvanced.addEventListener('click', () => this.toggleAdvanced());
                this.el.closeModal.addEventListener('click', () => this.hideDetails());
                this.el.modalBackdrop.addEventListener('click', () => this.hideDetails());
            }

            setupDragAndDrop() {
                const body = document.body;
                body.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    this.el.dragOverlay.style.display = 'flex';
                });
                body.addEventListener('dragleave', (e) => {
                    if (!body.contains(e.relatedTarget)) {
                        this.el.dragOverlay.style.display = 'none';
                    }
                });
                body.addEventListener('drop', (e) => {
                    e.preventDefault();
                    this.el.dragOverlay.style.display = 'none';
                    if (e.dataTransfer.files.length > 0) {
                        const file = e.dataTransfer.files[0];
                        this.importedFile = file;
                        this.inputMime = file.type || 'application/octet-stream';
                        this.el.inputText.value = '';
                        this.el.charCount.textContent = '';
                        this.el.inputInfo.textContent = `å·²å¯¼å…¥ï¼š${file.name} (${formatBytes(file.size)})`;
                    }
                });
            }

            toggleKeyInput() {
                this.el.keyInputContainer.classList.toggle('hidden', !this.el.useCustomKey.checked);
                this.updateKeyStrength();
            }

            toggleKeyVisibility() {
                const type = this.el.keyInput.type === 'password' ? 'text' : 'password';
                this.el.keyInput.type = type;
                this.el.toggleKeyVisibility.textContent = type === 'password' ? 'ğŸ‘ï¸' : 'ğŸ™ˆ';
            }

            updateKeyStrength() {
                const pass = this.el.useCustomKey.checked ? this.el.keyInput.value : '';
                const strength = evaluateKeyStrength(pass);
                this.el.keyStrengthBar.style.width = strength.percent + '%';
                this.el.keyStrengthText.textContent = `å¼ºåº¦ï¼š${strength.text}`;
                this.el.keyStrengthText.className = `ml-2 text-xs font-medium ${strength.color}`;
            }

            updateCharCount() {
                const len = this.el.inputText.value.length;
                this.el.charCount.textContent = `${len} å­—ç¬¦`;
            }

            handleFileImport(e) {
                const file = e.target.files[0];
                if (!file) {
                    this.importedFile = null;
                    this.inputMime = 'application/octet-stream';
                    this.el.inputInfo.textContent = '';
                    this.el.charCount.textContent = '0 å­—ç¬¦';
                    return;
                }
                this.importedFile = file;
                this.inputMime = file.type || 'application/octet-stream';
                this.el.inputText.value = '';
                this.el.charCount.textContent = '';  // æ–‡ä»¶æ¨¡å¼ä¸æ˜¾ç¤ºå­—ç¬¦æ•°
                this.el.inputInfo.textContent = `å·²å¯¼å…¥ï¼š${file.name} (${formatBytes(file.size)})`;
            }

            toggleAdvanced() {
                const hidden = this.el.advancedOptions.classList.toggle('hidden');
                this.el.toggleAdvanced.textContent = hidden ? 'æ˜¾ç¤ºé«˜çº§é€‰é¡¹' : 'éšè—é«˜çº§é€‰é¡¹';
            }

            showLoading() {
                this.el.loadingSpinner.style.display = 'block';
                this.isProcessing = true;
                this.el.operationStatus.textContent = 'å¤„ç†ä¸­...';
                this.el.operationStatus.classList.add('processing');
                this.updateUI();
            }

            hideLoading() {
                this.el.loadingSpinner.style.display = 'none';
                this.isProcessing = false;
                this.el.operationStatus.classList.remove('processing');
                this.updateUI();
            }

            updateProgress(processed, total) {
                const percent = Math.min(100, Math.round((processed / total) * 100));
                this.el.progressFill.style.width = percent + '%';
                this.el.progressPercent.textContent = percent + '%';
                this.el.processedSize.textContent = formatBytes(processed);
                this.el.totalSize.textContent = formatBytes(total);
                
                const elapsed = (performance.now() - this.processStartTime) / 1000;
                if (elapsed > 1) {
                    const speed = processed / elapsed;
                    const remaining = (total - processed) / speed;
                    this.el.remainingTime.textContent = remaining > 0 && isFinite(remaining) ? formatTime(remaining) : 'å³å°†å®Œæˆ...';
                } else {
                    this.el.remainingTime.textContent = 'è®¡ç®—ä¸­...';
                }
            }

            updateUI() {
                this.el.modeText.textContent = this.mode === 'encrypt' ? 'å½“å‰æ¨¡å¼ï¼šåŠ å¯†' : 'å½“å‰æ¨¡å¼ï¼šè§£å¯†';
                this.el.inputLabel.textContent = this.mode === 'encrypt' ? 'è¾“å…¥æ˜æ–‡æˆ–ä»»æ„æ–‡ä»¶' : 'è¾“å…¥å¯†æ–‡æˆ–å¯¼å…¥.enc';
                this.el.outputLabel.textContent = this.mode === 'encrypt' ? 'å¯†æ–‡ç»“æœ' : 'æ˜æ–‡/æ–‡ä»¶ç»“æœ';
                [this.el.encryptButton, this.el.decryptButton, this.el.clearButton].forEach(b => b.disabled = this.isProcessing);
            }

            getPassword() {
                if (this.el.useCustomKey.checked) {
                    if (!this.el.keyInput.value.trim()) throw new Error('å·²å¯ç”¨è‡ªå®šä¹‰å¯†é’¥ä½†æœªè¾“å…¥å¯†ç ');
                    return this.el.keyInput.value.trim();
                }
                return 'z7jgX9RwezqpY588dRphLRMTE3ie2uTX';
            }

            getSalt() {
                const val = this.el.saltInput.value.trim();
                if (val) {
                    if (!/^[0-9a-fA-F]+$/.test(val) || val.length % 2 !== 0) throw new Error('ç›å€¼å¿…é¡»ä¸ºæœ‰æ•ˆåå…­è¿›åˆ¶å­—ç¬¦ä¸²');
                    return hexToUint8(val);
                }
                return crypto.getRandomValues(new Uint8Array(16));
            }

            getIterations() {
                return Math.max(1000, Math.min(1000000, parseInt(this.el.iterationsInput.value) || 200000));
            }

            getChunkSize() {
                return Math.max(1, Math.min(100, parseInt(this.el.chunkSize.value) || 10)) * 1024 * 1024;
            }

            async handleEncrypt() {
                if (this.isProcessing) return;
                this.mode = 'encrypt';
                this.updateUI();
                this.processStartTime = performance.now();
                
                let writable = null;
                
                try {
                    this.showLoading();
                    this.el.processProgress.classList.add('active');
                    
                    let inputFile, inputBytes, fileSize;
                    if (this.importedFile) {
                        inputFile = this.importedFile;
                        fileSize = inputFile.size;
                    } else {
                        const text = this.el.inputText.value.trim();
                        if (!text) throw new Error('è¯·è¾“å…¥å†…å®¹æˆ–å¯¼å…¥æ–‡ä»¶');
                        inputBytes = new TextEncoder().encode(text);
                        fileSize = inputBytes.length;
                    }
                    
                    const password = this.getPassword();
                    const salt = this.getSalt();
                    const iterations = this.getIterations();
                    const { aesKey, hmacKeyBytes } = await deriveKeys(password, salt, iterations);
                    
                    const nonce = crypto.getRandomValues(new Uint8Array(16));
                    
                    const mimeBytes = new TextEncoder().encode(this.inputMime);
                    const mimeLen = Math.min(mimeBytes.length, MAX_MIME_LEN);
                    
                    const header = new Uint8Array(1 + 1 + 1 + 4 + 16 + 16 + mimeLen + 1);
                    let pos = 0;
                    header[pos++] = MAGIC_BYTE;
                    header[pos++] = CURRENT_VERSION;
                    header[pos++] = mimeLen;
                    new DataView(header.buffer).setUint32(pos, iterations, false);
                    pos += 4;
                    header.set(salt, pos); pos += 16;
                    header.set(nonce, pos); pos += 16;
                    header.set(mimeBytes.slice(0, mimeLen), pos); pos += mimeLen;
                    header[pos++] = SEPARATOR_BYTE;
                    
                    const fileName = inputFile ? inputFile.name + '.enc' : getTimestampFilename('encrypted', '.enc');
                    
                    let fileHandle = null;
                    if (window.showSaveFilePicker) {
                        try {
                            fileHandle = await window.showSaveFilePicker({
                                suggestedName: fileName,
                                types: [{
                                    description: 'Encrypted File',
                                    accept: { 'application/octet-stream': ['.enc'] }
                                }]
                            });
                            writable = await fileHandle.createWritable();
                            await writable.write(header);
                        } catch (e) {
                            if (e.name !== 'AbortError') throw e;
                        }
                    }
                    
                    const chunkSize = this.getChunkSize();
                    const hmac = new IncrementalHMAC(hmacKeyBytes);
                    hmac.update(header);
                    
                    const outputChunks = [];
                    
                    this.totalBytes = fileSize;
                    this.processedBytes = 0;
                    this.updateProgress(0, fileSize);
                    
                    let counter = 0;
                    let totalEncryptedSize = header.length;
                    
                    for (let offset = 0; offset < fileSize; offset += chunkSize) {
                        const end = Math.min(offset + chunkSize, fileSize);
                        let chunk;
                        
                        if (inputFile) {
                            const slice = inputFile.slice(offset, end);
                            chunk = new Uint8Array(await slice.arrayBuffer());
                        } else {
                            chunk = inputBytes.slice(offset, end);
                        }
                        
                        const counterNonce = new Uint8Array(nonce);
                        new DataView(counterNonce.buffer).setUint32(12, counter++, false);
                        
                        const encrypted = await crypto.subtle.encrypt(
                            { name: "AES-CTR", counter: counterNonce, length: 64 },
                            aesKey,
                            chunk
                        );
                        
                        const encryptedChunk = new Uint8Array(encrypted);
                        
                        hmac.update(encryptedChunk);
                        
                        if (writable) {
                            await writable.write(encryptedChunk);
                        } else {
                            outputChunks.push(encryptedChunk);
                        }
                        
                        totalEncryptedSize += encryptedChunk.length;
                        this.processedBytes = end;
                        this.updateProgress(this.processedBytes, this.totalBytes);
                        
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                    
                    const hmacTag = await hmac.finalize();
                    
                    if (writable) {
                        await writable.write(hmacTag);
                        await writable.close();
                    } else {
                        outputChunks.unshift(header);
                        outputChunks.push(hmacTag);
                        
                        const blob = new Blob(outputChunks, { type: 'application/octet-stream' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = fileName;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        setTimeout(() => URL.revokeObjectURL(url), 100);
                    }
                    
                    totalEncryptedSize += HMAC_TAG_LEN;
                    
                    this.el.outputText.value = `[åŠ å¯†å®Œæˆï¼æ–‡ä»¶å¤§å°ï¼š${formatBytes(totalEncryptedSize)}]\nå·²è‡ªåŠ¨ä¸‹è½½ä¿å­˜ä¸ºï¼š${fileName}`;
                    this.el.outputText.classList.remove('hidden');
                    
                    this.lastFileName = fileName;
                    this.lastResult = {
                        version: CURRENT_VERSION,
                        iterations,
                        mime: this.inputMime,
                        nonce: Array.from(nonce).map(b => b.toString(16).padStart(2,'0')).join(''),
                        salt: Array.from(salt).map(b => b.toString(16).padStart(2,'0')).join('')
                    };
                    
                    const elapsed = Math.round(performance.now() - this.processStartTime);
                    this.el.dataSize.textContent = formatBytes(totalEncryptedSize);
                    this.el.processingTime.textContent = `${(elapsed/1000).toFixed(2)} ç§’`;
                    this.el.operationStatus.textContent = 'âœ“ åŠ å¯†æˆåŠŸ';
                    this.el.operationStatus.className = 'text-green-600 font-medium';
                    this.el.showDetailsButton.classList.remove('hidden');
                    this.showMessage('åŠ å¯†æˆåŠŸï¼æ–‡ä»¶å·²ä¿å­˜', 'success');
                } catch (e) {
                    console.error(e);
                    if (writable) {
                        try { await writable.abort(); } catch {}
                    }
                    this.el.operationStatus.textContent = 'âœ— åŠ å¯†å¤±è´¥';
                    this.el.operationStatus.className = 'text-red-600 font-medium';
                    this.showMessage('åŠ å¯†å¤±è´¥ï¼š' + e.message, 'error');
                } finally {
                    this.hideLoading();
                    this.el.processProgress.classList.remove('active');
                }
            }

            async handleDecrypt() {
                if (this.isProcessing) return;
                this.mode = 'decrypt';
                this.updateUI();
                this.processStartTime = performance.now();
                
                let writable = null;
                
                try {
                    this.showLoading();
                    this.el.processProgress.classList.add('active');
                    
                    if (!this.importedFile) {
                        throw new Error('è§£å¯†éœ€è¦å¯¼å…¥.encæ–‡ä»¶');
                    }
                    
                    const encryptedFile = this.importedFile;
                    const fileSize = encryptedFile.size;
                    
                    const headerMinSize = 1 + 1 + 1 + 4 + 16 + 16 + 1;
                    if (fileSize < headerMinSize + HMAC_TAG_LEN) {
                        throw new Error('æ–‡ä»¶å¤ªå°ï¼Œä¸æ˜¯æœ‰æ•ˆçš„åŠ å¯†æ–‡ä»¶');
                    }
                    
                    const headerSlice = encryptedFile.slice(0, 1024);
                    const headerBytes = new Uint8Array(await headerSlice.arrayBuffer());
                    
                    let offset = 0;
                    if (headerBytes[offset++] !== MAGIC_BYTE) throw new Error('éæ³•æ–‡ä»¶ï¼šmagic byteé”™è¯¯');
                    const version = headerBytes[offset++];
                    if (version !== CURRENT_VERSION) throw new Error(`ä¸æ”¯æŒçš„ç‰ˆæœ¬ï¼š${version}ï¼ˆå½“å‰æ”¯æŒç‰ˆæœ¬${CURRENT_VERSION}ï¼‰`);
                    
                    const mimeLen = headerBytes[offset++];
                    const iterations = new DataView(headerBytes.buffer, headerBytes.byteOffset + offset, 4).getUint32(0, false);
                    offset += 4;
                    const salt = headerBytes.slice(offset, offset + 16); offset += 16;
                    const nonce = headerBytes.slice(offset, offset + 16); offset += 16;
                    const mimeType = mimeLen > 0 ? new TextDecoder().decode(headerBytes.slice(offset, offset + mimeLen)) : 'application/octet-stream';
                    offset += mimeLen;
                    
                    if (headerBytes[offset++] !== SEPARATOR_BYTE) {
                        throw new Error('æ–‡ä»¶ç»“æ„é”™è¯¯ï¼šMIMEåˆ†éš”ç¬¦ç¼ºå¤±');
                    }
                    
                    const headerSize = offset;
                    const dataSize = fileSize - headerSize - HMAC_TAG_LEN;
                    
                    if (dataSize < 0) {
                        throw new Error('æ–‡ä»¶æŸåï¼šæ•°æ®åŒºåŸŸè¿‡å°');
                    }
                    
                    const password = this.getPassword();
                    const { aesKey, hmacKeyBytes } = await deriveKeys(password, salt, iterations);
                    
                    const hmacStartPos = fileSize - HMAC_TAG_LEN;
                    const hmacSlice = encryptedFile.slice(hmacStartPos);
                    const storedHmac = new Uint8Array(await hmacSlice.arrayBuffer());
                    
                    const hmac = new IncrementalHMAC(hmacKeyBytes);
                    const chunkSize = this.getChunkSize();
                    
                    this.totalBytes = hmacStartPos;
                    this.processedBytes = 0;
                    this.updateProgress(0, this.totalBytes);
                    
                    for (let pos = 0; pos < hmacStartPos; pos += chunkSize) {
                        const end = Math.min(pos + chunkSize, hmacStartPos);
                        const chunk = new Uint8Array(await encryptedFile.slice(pos, end).arrayBuffer());
                        hmac.update(chunk);
                        this.processedBytes = end;
                        this.updateProgress(this.processedBytes, this.totalBytes);
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                    
                    const computedHmac = await hmac.finalize();
                    
                    let hmacValid = true;
                    if (computedHmac.length !== storedHmac.length) {
                        hmacValid = false;
                    } else {
                        for (let i = 0; i < computedHmac.length; i++) {
                            if (computedHmac[i] !== storedHmac[i]) {
                                hmacValid = false;
                                break;
                            }
                        }
                    }
                    
                    if (!hmacValid) {
                        throw new Error('HMAC éªŒè¯å¤±è´¥ï¼šæ–‡ä»¶å¯èƒ½è¢«ç¯¡æ”¹æˆ–å¯†ç é”™è¯¯');
                    }
                    
                    let baseName = this.importedFile.name.replace(/\.enc$/i, '');
                    let ext = getExtensionFromMime(mimeType);
                    if (!/\.\w+$/.test(baseName)) {
                        baseName += ext;
                    }
                    const outputFileName = baseName;
                    
                    let fileHandle = null;
                    if (window.showSaveFilePicker) {
                        try {
                            fileHandle = await window.showSaveFilePicker({
                                suggestedName: outputFileName,
                                types: [{
                                    description: 'Decrypted File',
                                    accept: { [mimeType]: [ext] }
                                }]
                            });
                            writable = await fileHandle.createWritable();
                        } catch (e) {
                            if (e.name !== 'AbortError') throw e;
                        }
                    }
                    
                    const outputChunks = [];
                    let counter = 0;
                    
                    this.processedBytes = 0;
                    this.totalBytes = dataSize;
                    this.updateProgress(0, dataSize);
                    
                    for (let pos = headerSize; pos < hmacStartPos; pos += chunkSize) {
                        const end = Math.min(pos + chunkSize, hmacStartPos);
                        const encryptedChunk = new Uint8Array(await encryptedFile.slice(pos, end).arrayBuffer());
                        
                        const counterNonce = new Uint8Array(nonce);
                        new DataView(counterNonce.buffer).setUint32(12, counter++, false);
                        
                        const decrypted = await crypto.subtle.decrypt(
                            { name: "AES-CTR", counter: counterNonce, length: 64 },
                            aesKey,
                            encryptedChunk
                        );
                        
                        const decryptedChunk = new Uint8Array(decrypted);
                        
                        if (writable) {
                            await writable.write(decryptedChunk);
                        } else {
                            outputChunks.push(decryptedChunk);
                        }
                        
                        this.processedBytes = end - headerSize;
                        this.updateProgress(this.processedBytes, this.totalBytes);
                        
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                    
                    if (writable) {
                        await writable.close();
                    } else {
                        const totalLen = outputChunks.reduce((sum, c) => sum + c.length, 0);
                        const plaintextBytes = new Uint8Array(totalLen);
                        let offset = 0;
                        for (const chunk of outputChunks) {
                            plaintextBytes.set(chunk, offset);
                            offset += chunk.length;
                        }
                        
                        if (plaintextBytes.length < 10 * 1024 * 1024) {
                            const isImage = mimeType.startsWith('image/');
                            const isText = mimeType.startsWith('text/') || isLikelyText(plaintextBytes);
                            
                            if (isImage) {
                                const blob = new Blob([plaintextBytes], { type: mimeType });
                                const url = URL.createObjectURL(blob);
                                this.el.outputImage.src = url;
                                this.el.outputImage.classList.remove('hidden');
                            } else if (isText) {
                                const text = new TextDecoder('utf-8').decode(plaintextBytes);
                                this.el.outputText.value = text.length > 100000 ? text.substring(0, 100000) + '\n\n... (å†…å®¹è¿‡é•¿ï¼Œå·²æˆªæ–­æ˜¾ç¤º)' : text;
                                this.el.outputText.classList.remove('hidden');
                                this.el.copyButton.classList.remove('hidden');
                            }
                        }
                        
                        const blob = new Blob([plaintextBytes], { type: mimeType });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = outputFileName;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        setTimeout(() => URL.revokeObjectURL(url), 100);
                    }
                    
                    this.el.outputText.value = `[è§£å¯†å®Œæˆï¼æ–‡ä»¶å¤§å°ï¼š${formatBytes(dataSize)}]\nå·²è‡ªåŠ¨ä¸‹è½½ä¿å­˜ä¸ºï¼š${outputFileName}`;
                    this.el.outputText.classList.remove('hidden');
                    
                    this.lastResult = {
                        version: CURRENT_VERSION,
                        iterations,
                        mime: mimeType,
                        nonce: Array.from(nonce).map(b => b.toString(16).padStart(2,'0')).join(''),
                        salt: Array.from(salt).map(b => b.toString(16).padStart(2,'0')).join('')
                    };
                    
                    const elapsed = Math.round(performance.now() - this.processStartTime);
                    this.el.dataSize.textContent = formatBytes(dataSize);
                    this.el.processingTime.textContent = `${(elapsed/1000).toFixed(2)} ç§’`;
                    this.el.operationStatus.textContent = 'âœ“ è§£å¯†æˆåŠŸ';
                    this.el.operationStatus.className = 'text-green-600 font-medium';
                    this.el.showDetailsButton.classList.remove('hidden');
                    this.showMessage('è§£å¯†æˆåŠŸï¼HMACéªŒè¯é€šè¿‡', 'success');
                } catch (e) {
                    console.error(e);
                    if (writable) {
                        try { await writable.abort(); } catch {}
                    }
                    this.el.operationStatus.textContent = 'âœ— è§£å¯†å¤±è´¥';
                    this.el.operationStatus.className = 'text-red-600 font-medium';
                    this.showMessage('è§£å¯†å¤±è´¥ï¼š' + e.message, 'error');
                } finally {
                    this.hideLoading();
                    this.el.processProgress.classList.remove('active');
                }
            }

            async downloadResult() {
                this.showMessage('æ–‡ä»¶å·²åœ¨åŠ å¯†/è§£å¯†æ—¶è‡ªåŠ¨ä¿å­˜', 'info');
            }

            handleClear() {
                this.el.useCustomKey.checked = false;
                this.el.keyInput.value = '';
                this.el.saltInput.value = '';
                this.el.iterationsInput.value = 200000;
                this.el.chunkSize.value = 10;
                this.el.inputText.value = '';
                this.el.outputText.value = '';
                this.el.outputImage.src = '';
                this.el.outputText.classList.add('hidden');
                this.el.outputImage.classList.add('hidden');
                this.el.charCount.textContent = '0 å­—ç¬¦';
                this.el.dataSize.textContent = '-';
                this.el.processingTime.textContent = '-';
                this.el.operationStatus.textContent = 'å°±ç»ª';
                this.el.operationStatus.className = 'text-gray-800';
                this.el.inputInfo.textContent = '';
                this.el.importFile.value = '';
                this.importedFile = null;
                this.inputMime = 'application/octet-stream';
                this.el.processProgress.classList.remove('active');
                [this.el.copyButton, this.el.downloadButton, this.el.showDetailsButton].forEach(b => b.classList.add('hidden'));
                this.toggleKeyInput();
                this.el.advancedOptions.classList.add('hidden');
                this.el.toggleAdvanced.textContent = 'æ˜¾ç¤ºé«˜çº§é€‰é¡¹';
                this.showMessage('å·²æ¸…ç©º', 'info');
            }

            copyResult() {
                navigator.clipboard.writeText(this.el.outputText.value).then(() => this.showMessage('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success'));
            }

            showDetails() {
                if (!this.lastResult) return;
                this.el.modalVersion.textContent = this.lastResult.version;
                this.el.modalIterations.textContent = this.lastResult.iterations;
                this.el.modalMime.textContent = this.lastResult.mime;
                this.el.modalIV.textContent = this.lastResult.nonce;
                this.el.modalSalt.textContent = this.lastResult.salt;
                this.el.detailsModal.classList.remove('hidden');
            }

            hideDetails() {
                this.el.detailsModal.classList.add('hidden');
            }

            showMessage(msg, type = 'info') {
                const el = document.createElement('div');
                el.className = `fixed top-4 right-4 px-6 py-3 rounded-lg shadow-lg z-50 text-white font-medium`;
                el.className += type === 'success' ? ' bg-green-600' : type === 'error' ? ' bg-red-600' : ' bg-blue-600';
                el.textContent = msg;
                document.body.appendChild(el);
                setTimeout(() => {
                    el.style.opacity = '0';
                    el.style.transition = 'opacity 0.5s';
                    setTimeout(() => el.remove(), 500);
                }, 3000);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            if (!window.hashwasm || !window.hashwasm.HmacSha256) {
                alert('hash-wasm åŠ è½½å¤±è´¥ï¼ˆCDN åœ¨å½“å‰ç½‘ç»œä¸å¯ç”¨ï¼‰');
                console.error('hashwasm:', window.hashwasm);
                return;
            }
            new App();
        });

    </script>
</body>
</html>
